# ![](https://ga-dash.s3.amazonaws.com/production/assets/logo-9f88ae6c9c3871690e33280fcf557f33.png) Project #3: Sinatra API Backend with a React Front End

### Overview

This project is a chance to flex your MVC muscles in a new language—Ruby—and show off your new React prowess.

Before you start, sketch your wireframes and write user stories to define what your users will want to do with the app. Run your database schema, your user stories, and your wireframes by your instructors to get their feedback before you dive into code! Remember to keep things small and focus on mastering the fundamentals – scope creep/feature creep is the biggest pitfall for any project! Set up some easily achievable MVP goals, a couple goals you might get to, and a couple stretch goals that you probably won't get to. We will be making sure that before you start you have a solid understanding of the data your program will use, the structures/relations you're planning create with it on the back end, and generally the way it fits into the UI flow of your front end.

---

### Technical Requirements

Your app must:

* be an SPA you built consuming an API you built
* **Have at _least_ 2 RELATED models** (but more is great) – Of course you'll have a user model with login/etc. Bare minimum is you must have a relation between that user and some model in that app. If you can do it we'd love to see a second model (and third and fourth, if necessary) related to that one.
* **Include sign up/log in functionality**, with encrypted passwords & an authorization flow
* **Include wireframes in the README.md for the React repo AT presentation time** 
* Have **semantically clean code**
* **Be deployed online** and accessible to the public--we'll show you how to deploy to heroku for both Sinatra and React (its v v easy).

---

### Necessary Deliverables

* A **working Sinatra API and React front end that consumes it, built by you**
* Both should be live and publicly accessible on the internet
* **Two corresponding git repositories hosted on Github**, with links to the hosted project, and frequent commits dating back to the **very beginning** of the project. Try to make each commit represent a completed improvement—i.e. try not to commit/push: 
  * code that isn't working, or
  * code that still has 230986 console.logs -- delete them once you've solved whatever you put them in to solve
  * unused/commented-out code 
* Sinatra/API `README.md`: try to include at least minimal concise documentation for your API describing each route, how to access it, and what kind of response the user can expect back from it. Ideally any random person should only need to read that to use your API. Consult other API documentation you've used for examples.
* **React ``README.md``** should include the following:
  * A **link to your hosted working React App** in the URL section of your Github repo for your react app.
  * **user stories**
  * **wireframes**
  * what is it?
  * why did you make it?
  * what problem(s) does it solve?
  * explanations of the technologies used/approach taken
  * installation instructions 
  * next steps (frame features you didn't finish as "forthcoming" instead of "here's what's broken still")


---

### Suggested Ways to Get Started

* **Begin with the end in mind.** Know where you want to go by planning with wireframes & user stories, so you don't waste time building things you don't need. Keep it lean and keep it elegant.
* As your wireframes are taking shape, you should be figuring out what data you're going to have, and what the database schemas will look like.  Don't start developing until you have **a solid plan/understanding about what data you'll be using exactly, the schemas, and the relevant relations.**
* **Don’t hesitate to write throwaway code to solve short term problems**
* **Read the docs for whatever technologies you use.** Most of the time, there is a tutorial that you can follow, but not always, and learning to read documentation is crucial to your success as a developer
* **Commit early, commit often.** Don’t be afraid to break something because you can always go back in time to a previous version.
* **User stories define what a specific type of user wants to accomplish with your application**. It's tempting to just make them _todo lists_ for what needs to get done, but if you keep them small & focused on what a user cares about from their perspective, it will help you make important development decisions
* **Write pseudocode before you write actual code.** By this point, you're likely realizing the benefit of thinking through your logic this way.

---

### Potential Project Ideas

##### Cat Video App
Create an app that will allow people to share their favorite cat videos on Youtube. A user submits the video, and other users can comment on the video. Users can also up/down vote videos/comments.

##### Burrito Builder App
You will create an application where users can create and share their favorite burritos.

##### Photo sharing app
Users will be able to register and create albums and photos. Albums and photos will need to be named and described by their owners. Users will be able to view other users' albums. Maybe users can comment on photos, or either up/down vote them.

##### Restaurant or coffee shop software

##### Doctor's office software to track appointments or conditions

##### Something totally wild and off the map that we never would have thought of—be as creative as you like.

---

### Useful Resources

* **[Heroku](http://www.heroku.com)** _(for hosting your back-end)_
* **[Writing Good User Stories](http://www.mariaemerson.com/user-stories/)** _(for a few user story tips)_
* **[Presenting Information Architecture](http://webstyleguide.com/wsg3/3-information-architecture/4-presenting-information.html)** _(for more insight into wireframing)_

---

### Project Feedback + Evaluation

* __Project Workflow__: Did you complete the user stories, wireframes, task tracking, and/or ERDs, as specified above? Did you use source control as expected for the phase of the program you’re in (detailed above)?

* __Technical Requirements__: Did you deliver a project that met all the technical requirements? Given what the class has covered so far, did you build something that was reasonably complex?

* __Creativity__: Did you added a personal spin or creative element into your project submission? Did you deliver something of value to the end user (not just a login button and an index page)?

* __Code Quality__: Did you follow code style guidance and best practices covered in class, such as spacing, modularity, and semantic naming? Did you comment your code as your instructors as we have in class?

* __Deployment and Functionality__: Is your application deployed and functional at a public URL? Is your application free of errors and incomplete functionality?

* __Total__: Your instructors will give you a total score on your project between:

    Score | Expectations
    ----- | ------------
    **0** | _Incomplete._
    **1** | _Does not meet expectations._
    **2** | _Meets expectactions, good job!_
    **3** | _Exceeds expectations, you wonderful creature, you!_

 This will serve as a helpful overall gauge of whether you met the project goals, but __the more important scores are the individual ones__ above, which can help you identify where to focus your efforts for the next project!
